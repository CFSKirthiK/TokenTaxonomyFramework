syntax = "proto3";

package taxonomy.model.core;

import "google/protobuf/any.proto";
import "artifact.proto";

option csharp_namespace = "TTI.TTF.Taxonomy.Model.Core";
option java_package = "org.tti.ttf.taxonomy.model.core";
option java_multiple_files = true;

enum InfluenceType {
    INTERCEPT = 0;
    OVERRIDE = 1;
}

//all tokens inherit from the base and implicitly support construction.  The properties represent non-behavioral properties, with the exception of Decimals which is used by the Subdividable or Non-Subdividable behavior where any value greater than 0 makes the token subdividable.
message Base{
    taxonomy.model.artifact.Artifact artifact = 1;
    taxonomy.model.artifact.TokenType token_type = 2;
    taxonomy.model.artifact.TokenUnit token_unit = 3;
    taxonomy.model.artifact.RepresentationType representation_type = 4;
    taxonomy.model.artifact.ValueType value_type = 5; //override this from the default of Intrinsic in the BaseReference for a TemplateDefinition to Reference type if needed.
    string name = 6;  //A common well understood name that represents the Token Class.  All instances, or tokens, within this class will be referred to by their class name.
    string symbol = 7; //an optionally unique symbol or identifier
    string owner = 8; //A reference to the owner of the token class or instance which can be a blockchain address, public key or other unique identifier.
    int64 quantity = 9; //Base64 encoded ByteString - can represent the initial quantity created or the total minted or issued for the class.
    int32 decimals = 10; //A number of decimal places a single token can be subdivided into.  A typical fiat currency has a value of 2, i.e. $100.53. A value of 0 means that subdivision is not supported and a whole token is the smallest unit of the token that can be owned.
    map<string, string> token_properties = 11; //Generic non-behavioral properties as a list of simple `name, value` pairs that can be implemented without property invocations for each.
    string constructor_name = 12; //a template must have a constructor, the name is the proto3 message name in the implemented token base definition.  The default is Constructor.
    google.protobuf.Any constructor = 13; //the constructor type defined in the token template artifact.
}

message Bases{
    repeated Base base = 1;
}

message BaseReference {
    taxonomy.model.artifact.ArtifactReference reference = 1;
    taxonomy.model.artifact.ValueType value_type = 2; //set this to change from the default of intrinsic if it is a reference value token.
    string name = 3;  //A common well understood name that represents the Token Class.  All instances, or tokens, within this class will be referred to by their class name.
    string symbol = 4; //an optionally unique symbol or identifier
    string owner = 5; //A reference to the owner of the token class or instance which can be a blockchain address, public key or other unique identifier.
    int64 quantity = 6; //Can represent the initial quantity created or the total minted or issued for the class.
    int32 decimals = 7; //A number of decimal places a single token can be subdivided into.  A typical fiat currency has a value of 2, i.e. $100.53. A value of 0 means that subdivision is not supported and a whole token is the smallest unit of the token that can be owned.
    map<string, string> token_properties = 8; //Generic non-behavioral properties as a list of simple `name, value` pairs that can be implemented without property invocations for each.
    string constructor_name = 9; //a template must have a constructor, the name is the proto3 message name in the implemented token base definition.  The default is Constructor.
    google.protobuf.Any constructor = 10; //the constructor type defined in the token template artifact.
}

//Behaviors

message Behavior{
    taxonomy.model.artifact.Artifact artifact = 1;
    bool is_external = 2;
    string constructor_type = 3; //proto message name empty if there is no constructor, used when unpacking the Any.
    google.protobuf.Any constructor = 4; //optionally retrieved for behaviors like Role Support that needs input when setting up the roles when the token class is created.  Uses Any as the type as it will not be known by the framework.
    repeated Invocation invocations = 5;//definitions only will not have values, null for string or composite types and 0 for numbers, false for bools.
    repeated Property properties = 6; //for any properties that should be added to the token if the behavior is implemented, values not set, should consider a dependent property-set.
}

message Behaviors{
    repeated Behavior behavior = 1;
}


message BehaviorGroup{
    taxonomy.model.artifact.Artifact artifact = 1;
    repeated BehaviorReference behaviors = 2;
    map<string, Behavior> behavior_artifacts = 3; //if retrieved this can be populated with the behaviors nested in the group.
}

message BehaviorGroups{
    repeated BehaviorGroup behavior_group = 1;
}

message BehaviorGroupReference{
    taxonomy.model.artifact.ArtifactReference reference = 1;
    repeated BehaviorReference behavior_artifacts = 2; //if retrieved this can be populated with the behaviors nested in the group.
}

message PropertySet{
    taxonomy.model.artifact.Artifact artifact = 1;
    repeated Property properties = 2; //definitions only will not have values, null for string or composite types and 0 for numbers, false for bools.
}

message PropertySets{
    repeated PropertySet property_set = 1;
}

message PropertySetReference{
    taxonomy.model.artifact.ArtifactReference reference = 1;
    repeated Property properties = 2; //values
}

//------------------------Properties and Invocations--------------

message Property{
    string name = 1;
    string value_description = 2; 
    string template_value = 3; //value, if needed, when applied to template
    repeated Invocation property_invocations = 4; //needed for non-behavioral properties
    repeated Property properties = 5;
}

message Invocation{
    string id = 1; //invocations are given a UUID/GUID to correctly identify influences within a definition, particularly if there is an overloaded invocation, meaning a involcation with the same name but different parameters
    string name = 2; //property name if a property-set
    string description = 3; //include the data type for the value.
    InvocationRequest request = 4;
    InvocationResponse response = 5;
}

message InvocationRequest{
    string control_message_name = 1;
    string description = 2;
    repeated InvocationParameter input_parameters = 3;
}

message InvocationResponse{
    string control_message_name = 1;
    string description = 2;
    repeated InvocationParameter output_parameters = 3;
}

message InvocationParameter{
    string name = 1;
    string value_description = 2; //describe the data type and restrictions like length.
}

//-----------------------------Template Formula and Definitions----------------
//TokenTemplate is composed when the model is built using the hierarchy of the TemplateFormula followed by the TemplateDefinition.
message TokenTemplate{
    TemplateFormula formula = 1;
    TemplateDefinition definition = 2;
}

//maped to ArtifactSymbol.Id of the TemplateDefinition.  
message TokenTemplates{
    map<string, TokenTemplate> template = 1;
}

//Represents the Template Formula that is used in combination to validate a TemplateDefinition.
message TemplateFormula{
    taxonomy.model.artifact.Artifact artifact = 1;
    taxonomy.model.artifact.TemplateType template_type = 2;
    TemplateBase token_base = 3;
    repeated TemplateBehavior behaviors = 4;
    repeated TemplateBehaviorGroup behavior_groups = 5;
    repeated TemplatePropertySet property_sets = 6;
    repeated TemplateFormula child_tokens = 7; //if hybrid, this can contain the list of child token classes.
}

message TemplateFormulas{
    repeated TemplateFormula templates = 1;
}

message TemplateBase {
    taxonomy.model.artifact.ArtifactSymbol base = 1; //usually from the template parent
}
//used to wrap the base token type for a template with implementation details specific for the behavior's use in this token template definition.
message TemplateBehavior{
    taxonomy.model.artifact.ArtifactSymbol behavior = 1;
}
//used to wrap the base token type for a template with implementation details specific for the BehaviorGroup's use in this token template definition.
message TemplateBehaviorGroup{
    taxonomy.model.artifact.ArtifactSymbol behavior_group = 1;
}
//used to wrap the base token type for a template with implementation details specific for the Property-set's use in this token template definition.
message TemplatePropertySet{
    taxonomy.model.artifact.ArtifactSymbol property_set = 1;
}

//TemplateDefinition, the Artifact.ArtifactSymbol.Id is the primary identifier for a TokenTemplate.
message TemplateDefinition{
    taxonomy.model.artifact.Artifact artifact = 1;
    taxonomy.model.artifact.ArtifactReference formula_reference = 2;
    BaseReference token_base = 3;
    repeated BehaviorReference behaviors = 4;
    repeated BehaviorGroupReference behavior_groups = 5;
    repeated PropertySetReference property_sets = 6;
    repeated TemplateDefinition child_tokens = 7;
}

message TemplateDefinitions{
    repeated TemplateDefinition definitions = 1;
}

message BehaviorReference{
    taxonomy.model.artifact.ArtifactReference reference = 1;
    bool is_external = 2;
    string constructor_type = 3; //proto message name empty if there is no constructor, used when unpacking the Any.
    google.protobuf.Any constructor = 4; //optionally retrieved for behaviors like Role Support that needs input when setting up the roles when the token class is created.  Uses Any as the type as it will not be known by the framework.
    repeated taxonomy.model.artifact.ArtifactSymbol applies_to = 5; //if this is an influence behavior, list the influenced symbols here, the details on how it influences is in the influence bindings.
    repeated Invocation invocations = 6; //updated invocations from the base artifact
    repeated InfluenceBinding influence_bindings = 7; //influence invocation definitions, only defined in the influencing behavior, but applied during specification generation.
    repeated Property properties = 8; //values
}

//use these to define the influencing behavior's invocation and it's target to influence within the definition, the TTF will use this to construct the Invocation Pipeline.
message InfluenceBinding{
    string influenced_id = 1; //the artifactId being invluenced
    string influenced_invocation_id = 2; //the invocationId in the influenced artifact to be influenced.
    InfluenceType influence_type = 3; //override or intercept
    Invocation influencing_invocation = 4; //if it is an intercept, this is the intercepting invocation, if it is override it is the modified invocation
    Invocation influenced_invocation = 5; // if it is an intercept this is the invocation that occurs after being intercepted. If it is an override
}


//----------------------Specification----------------
//used to dynamically build the entire Token Specification with all objects merged. Handy for documentation.
message TokenSpecification{
    string specification_hash = 1;
    taxonomy.model.artifact.Artifact artifact = 2;
    taxonomy.model.artifact.ArtifactReference definition_reference = 3;
    Base token_base = 4;
    repeated BehaviorSpecification behaviors = 5;
    repeated BehaviorGroupSpecification behavior_groups = 6;
    repeated PropertySetSpecification property_sets = 7;
    repeated TokenSpecification child_tokens = 8;
}

message BehaviorSpecification{
    taxonomy.model.artifact.Artifact artifact = 1;
    bool is_external = 2;
    string constructor_type = 3; //proto message name empty if there is no constructor, used when unpacking the Any.
    google.protobuf.Any constructor = 4; //optionally retrieved for behaviors like Role Support that needs input when setting up the roles when the token class is created.  Uses Any as the type as it will not be known by the framework.
    repeated InvocationBinding invocations = 5;//definitions only will not have values, null for string or composite types and 0 for numbers, false for bools.
    repeated Property properties = 6; //for any properties that should be added to the token if the behavior is implemented, values not set, should consider a dependent property-set.
}

message PropertySetSpecification{
    taxonomy.model.artifact.Artifact artifact = 1;
    repeated PropertySpecification properties = 6; //for any properties that should be added to the token if the behavior is implemented, values not set, should consider a dependent property-set.
}

message PropertySpecification{
    string name = 1;
    string value_description = 2; 
    string template_value = 3; //value, if needed, when applied to template
    repeated InvocationBinding property_invocations = 4; //needed for non-behavioral properties
    repeated PropertySpecification properties = 5;
}

message BehaviorGroupSpecification{
    taxonomy.model.artifact.Artifact artifact = 1;
    repeated taxonomy.model.artifact.ArtifactSymbol behaviors = 2; //the behaviors in the group
}

message InvocationBinding{
    message Influence{
        InfluenceType influence_type = 1;
        string influencing_id = 2; //the influencing artifactId
        string influencing_invocation_id = 3;
        string influenced_id = 4;
        string influenced_invocation_id = 5;
    }
    Influence influence = 1;
    message InvocationStep{
        Invocation invocation = 1;
        InvocationStep next_invocation = 2; 
    }
    InvocationStep invocation_step = 2;
}

message TokenBase {
    Base base = 1;
    BaseReference values = 2;
}

message TokenBehavior {
    Behavior behavior = 1;
    BehaviorReference values = 2;
}

message TokenBehaviorGroup {
    BehaviorGroup behavior = 1;
    BehaviorGroupReference values = 2;
}

message TokenPropertySet {
    PropertySet property_set = 1;
    PropertySetReference values = 2;
}