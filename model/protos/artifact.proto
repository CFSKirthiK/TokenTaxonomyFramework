syntax = "proto3";

package taxonomy.model.artifact;
import "google/protobuf/any.proto";

option csharp_namespace = "TTI.TTF.Taxonomy.Model.Artifact";
option java_package = "org.tti.ttf.taxonomy.model.artifact";
option java_multiple_files = true;

enum TemplateType{
    SINGLE_TOKEN = 0;
    HYBRID = 1;
}

enum TokenType {
    FUNGIBLE = 0;
    NON_FUNGIBLE = 1;
}

//classification for Templates, parent and any child tokens. 
enum TokenUnit{
    FRACTIONAL = 0; //tF{d} or tN{d}
    WHOLE = 1; //tF{~d} or tN{~d}
    SINGLETON = 2; //tN{~s} - quantity = 1
}

enum ArtifactType{
    BASE = 0; //from core.Type
    BEHAVIOR = 1; 
    BEHAVIOR_GROUP = 2;
    PROPERTY_SET = 3;
    TEMPLATE_FORMULA = 4;
    TEMPLATE_DEFINITION = 5;
    TOKEN_TEMPLATE = 6;
}

enum ArtifactContent {
    DEFINITION = 0; //html, MD, etc.
    CONTROL = 1; //proto
    UML = 2; //md or other host UML
    OTHER = 3; //any
}

enum MappingType{
    SOURCE_CODE = 0;
    IMPLEMENTATION = 1;
    RESOURCE = 2; //to an external informational source like a regulatory framework or related issue
}

enum TargetPlatform{
    ETHEREUM_SOLIDITY = 0;
    CHAINCODE_GO = 1;
    CHAINCODE_JAVA = 2;
    CHAINCODE_NODE = 3;
    CORDA = 4;
    DAML = 5;
}

//types 

message Classification{
    TemplateType template_type = 1;
    TokenType token_type = 2;
    TokenUnit token_unit = 3;
}

message ArtifactSymbol{
    string id = 1;
    ArtifactType type = 2;
    string visual = 3; //symbol for single artifact and formula for templates
    string tooling = 4; //symbol for single artifact and formula for templates
    string version = 5;
    bool template_validated = 6; //for templates only
}

//contains artifact metadata structure
message Artifact {
    ArtifactSymbol artifact_symbol = 1;
    string name = 2;
    repeated string aliases = 3;
    ArtifactDefinition artifact_definition = 4; //Base, Behavior or Behavior group type indicated by ArtifactType
    repeated SymbolDependency dependencies = 5; //Typically used for a behavior that has a dependency on a property-set.
    repeated ArtifactSymbol incompatible_with_symbols = 6; //for behaviors that have opposites, or if another behavior or property-set
    repeated SymbolInfluence influenced_by_symbols = 7;
    string control_uri = 8;
    repeated ArtifactFile artifact_files = 9; //Can be overriden by ArtifactReferenceValues loop through the files and read them in as bytes to produce a complete artifact object model instance.
    Maps maps = 10; //Can be overriden by ArtifactReferenceValues loop through the files and read them in as bytes to produce a complete artifact object model instance.
}

message ArtifactReferenceValues{
    string control_uri = 1;
    repeated ArtifactFile artifact_files = 2; //loop through the files and read them in as bytes to produce a complete artifact object model instance.
    Maps maps = 3;
}

//a reference to another artifact, either TemplateBranch to TemplateBranch, or ArtifactInstance to Artifact.
message ArtifactReference{
    string id = 1; 
    ArtifactType type = 2;
    string reference_notes = 3;
    ArtifactReferenceValues values = 4;
}

message SymbolInfluence{
    string description = 1; //describe how the symbol influences this artifact, like non-sub-dividable or delegable.
    ArtifactSymbol symbol = 2;
    repeated ArtifactSymbol applies_to = 3; //list of behaviors or property-sets that are influenced by this symbol.
}

message SymbolDependency{
    string description = 1; //describe how the symbol influences this artifact, like non-sub-dividable or delegable.
    ArtifactSymbol symbol = 2;
}

message ArtifactDefinition{
    string business_description = 1;
    string business_example = 2;
    repeated ArtifactAnalogy analogies = 3;
    string comments = 4;
    Artifact artifact = 5; //navigation to parent
}

message ArtifactAnalogy{
    string name = 1;
    string description = 2;
    ArtifactDefinition artifact_definition = 3; //navigation to parent
}

message ArtifactFile{
    ArtifactContent content = 1; 
    string file_name = 2;
    bytes file_data = 3;
    Artifact artifact = 4; //navigation to parent
}

message Maps{
    repeated MapReference code_references = 1;
    repeated MapReference implementation_references = 2;
    repeated MapResourceReference resources = 3;
    Artifact artifact = 4; //navigation to parent
}

message MapReference{
    MappingType mapping_type = 1;
    string name = 2;
    TargetPlatform platform = 3;
    string reference_path = 4;
    Maps maps = 5; //navigation to parent
}

message MapResourceReference{
    MappingType mapping_type = 1;
    string name = 2;
    string description = 3;
    string resource_path = 4;
    Maps maps = 5; //navigation to parent
}

//Commands
message NewArtifactRequest{
    ArtifactType type = 1;
    google.protobuf.Any artifact = 2;
}

message NewArtifactResponse{
    ArtifactType type = 1;
    google.protobuf.Any artifact_type_object = 2; //deserialize based on type
}

message UpdateArtifactRequest{
    ArtifactType type = 1;
    google.protobuf.Any artifact_type_object = 2;//deserialize based on type
}

message UpdateArtifactResponse{
    ArtifactType type = 1;
    bool updated = 2;
    google.protobuf.Any artifact_type_object = 3; //updated type, deserialize based on type
}

message DeleteArtifactRequest{
    ArtifactSymbol artifact_symbol = 1;//deserialize based on type
}

message DeleteArtifactResponse{
    bool deleted = 1;
}

message FormulaGrammar{
    SingleTokenGrammar single_token_grammar = 1;
    HybridTokenGrammar hybrid_grammar = 2;
    HybridTokenWithHybridChildrenGrammar hybrid_with_hybrids_grammar = 3;
}

message HybridTokenGrammar{
    SingleTokenGrammar parent = 1;
    string children_start = 2; // "("
    repeated SingleTokenGrammar child_tokens = 3;
    string children_end = 4; // ")"
}

message HybridTokenWithHybridChildrenGrammar{
    SingleTokenGrammar parent = 1;
    string hybrid_children_start = 2; // "("
    repeated HybridTokenGrammar hybrid_child_tokens = 3;
    string hybrid_children_end = 4; // ")"
}

//outermost grouping container for the formula for a whole template either a parent or hybrid child.
message SingleTokenGrammar{
    string group_start = 2; // "["
    string base_token_tooling_symbol = 3;
    BehaviorList behaviors = 4;
    PropertySetList property_sets = 5;
    string group_end = 6; // "]"
}

message BehaviorList{
    string list_start = 1; // "{"
    repeated string behavior_tooling_symbols = 2; // lowercase letters for individual behaviors, UPPERCASE for behaviorGroup
    string list_end = 3; // "}"
}

message PropertySetList{
    string list_start = 1; // "+"
    repeated PropertySetListItem property_sets = 2; //model builder should put a comma between multiple sets.
}

message PropertySetListItem{
    string property_set_symbol = 2; // starts with ph followed by Camel case name or symbol.
}

message CommitUpdatesRequest{
    string commit_message = 1;
}

message CommitUpdatesResponse{
    string result = 1;
}

message IssuePullRequest{

}

message IssuePullResponse{
    string response = 1;
}

message ConfigurationRequest{

}

message ServiceConfiguration{
    bool read_only = 1;
    string git_id = 2;
    string git_branch = 3;
}

message QueryOptions{
    ArtifactType artifact_type = 1;
    int32 max_item_return = 2;
    int32 last_item_index = 3; //set to the QuertResult.LastItemIndex from the previous QueryResult. Manually override from QueryResult FirstItemIndex + count in results array
    bool by_classification = 4; //if true, the TemplateClassification value will apply, if false, it will search all templates.
    Classification classification = 5; //only if quering templates
    bool include_hybrids = 6; //only if quering templates
}

message QueryResult{
    ArtifactType artifact_type = 1;
    int32 first_item_index = 2;
    int32 last_item_index = 3;
    int32 total_items_in_collection = 4; //total count in the collection if iterating through all the items on the service of the specified type.
    google.protobuf.Any artifact_collection = 5; //deserialize to the collection object for the ArtifactType, i.e. Base will be a Bases, Behavior will be Behaviors, etc.
}

//used to query for a TokenTemplate and to Build the TemplateSpecification
message TokenTemplateId{
    string definition_id = 1;
}

//generic argument for fetching an artifact by its ArtifactSymbol.Id
message Identifier{
    string id = 1;
}

message NewTemplateDefinition{
    string template_formula_id = 1;
    string token_name = 2;
}

message InitializeNewArtifactRequest {
    ArtifactType artifact_type = 1;
    string name = 2; 
    string symbol = 3; //ignored if a TemplateFormula
    TemplateType template_type = 4; //ignored if not a TemplateFormula
    TokenType token_type = 5; //ignored if not a TemplateFormula
    TokenUnit token_unit = 6; //ignored if not a TemplateFormula
}

message InitializeNewArtifactResponse {
    ArtifactType artifact_type = 1;
    google.protobuf.Any artifact = 2;
}